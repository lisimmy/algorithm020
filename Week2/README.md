学习笔记

HASH、SET：
	工作中常用的  数组、链表、map和set ， map和set 底层一般是hash表实现， 也有是用二叉树实现

	设计一个合理的哈希函数，是最重要的。 如果要自己实现哈希表，需要根据数据的情况，设计哈希函数，减少碰撞，使得数据尽量分散
	如果碰撞发生， 可以使用链表解决碰撞（拉链法）
	
	
	哈希函数， 返回一个index， 是整数，作为寻找某个结点的下标
	
	理解：
	map和set的区别


解决问题的4步：
	1. 确认问题（确认问题理解正确 ）
	2. 列出多种所有可能的解决方案，选择最优的解决方案
	3. 编码
	4. 调试、测试


树、二叉树、二叉搜索树：
	如何加速?
	 升维， 比如由单链表升维到 跳表， 类似增加了索引
	
	一维结构升维后：
	树、二叉树、 二叉搜索树、 
	
	图， 链表是特殊的树，树（没有环的图）是特殊的图
	
	树形结构更贴近于生活，实际问题中，比如决策树、期望货币价值等
	
	
	树的三种不同的遍历方式（树的遍历使用递归， 无法或者很难实现有效的循环来进行遍历，递归更简单）

	二叉树的树的遍历， 递归实现和线性实现， 颜色标记法（手动实现栈）
	
	学习笔记： 不要规避递归， 递归本身是没问题的， 只要不把代码写的太烂， 递归也是进行函数压栈处理，多次压栈出栈。

堆
	二叉堆： 堆的一种实现方式， 相比其他的堆的实现方式， 实现比较容易， 效率是比较低的
	
	效率比较高的有，斐波那契堆， 严格的斐波那契堆， 是多叉树实现
	
	二叉搜索树， 是排序好的， find-min和find-max是logN的
	
	二叉堆
	二叉堆一般都通过“数组”来实现
	
	2. 假设“第一个元素“在数组中的索引为 0 的话
	
	则父节点和子节点的位置关系如下
	(1) 索引为 i 的左孩子的索引是（2*i+1)    
	(2) 索引为 i 的右孩子的索引是（2i+2 
	(3) 索引为的父结点的索引是 floor((i-1)/2)
INSERT 插入：  LogN

1. 首先插入到二叉堆的尾部（也就是数组的尾部）
2. 插入的结点依次跟其父结点比较， 如果大于父结点，那么跟父结点交换， 直到不大于父结点为止
3. 此时的二叉堆维护结束

向上调整 heapify up


delete删除  LogN
1. 首先用堆尾部的值，将堆顶部元素替换。
2. 此时比较堆顶的左右孩子， 并与较大的孩子交换为止
3. 依次执行2， 与下一层的左右孩子比较，与较大的孩子交换位置
4. 不再小于左右孩子，那么结束

向下调整 heapify down